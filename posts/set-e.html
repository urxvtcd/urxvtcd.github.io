<!DOCTYPE html><html lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name="theme-color" content="#66023C"><meta name="color-scheme" content="light dark"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><style type="text/css">:root{--footer-height:9rem;--content-width:40rem;--content-x-padding:1.5rem}h1{font-size:3rem;line-height:1.1}body{line-height:1.5;margin:0}#nav-body{min-height:calc(100svh - var(--footer-height))}main,nav,#footer-content{max-width:var(--content-width);margin:0 auto}main,nav{padding:1rem var(--content-x-padding)}nav a{font-size:smaller;text-decoration:none;font-weight:bold}nav ul,nav li{display:inline;margin-right:1em}footer{font-size:smaller;background:#66023C;color:white}#snail{max-width:50%;margin:0 auto;height:auto;display:block}#footer-content{height:var(--footer-height);padding:0 var(--content-x-padding);display:flex;align-items:center}pre code{overflow:auto}main{hyphens:auto}body{font-family:sans-serif}h1{hyphens:none}.aside,blockquote,pre code{padding:.5em}.aside{border-top:thin solid;border-bottom:thin solid;font-size:smaller}p:first-child{margin-top:0}p:last-child{margin-bottom:0}img{max-width:100%}sup{vertical-align:baseline;position:relative;top:-0.4em}blockquote,li,p{text-align:justify}span.published-date{font-size:smaller}code{font-style:normal;padding:.1em .2em;white-space:pre;font-family:monospace,monospace}pre code{border:thin solid;display:block;font-size:smaller}blockquote{margin:0;border-left:thin solid;font-style:oblique}ol,ul{margin-left:0;padding-left:0}#post-listing li{list-style-type:none}#skip{background:#66023C;color:white;padding:.3em;position:absolute;transform:translateY(-100%)}#skip:focus{transform:translateY(0%)}</style><title>Playing with set -e in shell scripts</title><script>window.matchMedia('(prefers-color-scheme:dark)').addEventListener('change',event=>document.documentElement.style["color-scheme"]=event.matches?"dark":"light");</script><div id="nav-body"><a href="#main" id="skip">Skip to content</a><nav><ul><li><a href="/index.html">snails.dev</a></ul></nav><main id="#main"><section id="Playing-with-set--e-in-shell-scripts"><h1>Playing with set -e in shell scripts</h1><p><span class="published-date">2023-02-25</span><p>At one of my previous teams, we laughed at how <s>much of an overkill</s> state-of-the-art some of our practices were. In particular, for a shell script to be considered <s>a cargo-cult</s> state-of-the-art, it had to include this line somewhere at the beginning:<pre><code>set -Eeuxo pipefail
</code></pre><p>I’ll focus on the <code>-e</code> part—an option called <em>errexit</em>. <code>man dash</code> gives the following description:<blockquote><p>If not interactive, exit immediately if any untested command fails. The exit status of a command is considered to be explicitly tested if the command is used to control an <code>if</code>, <code>elif</code>, <code>while</code>, or <code>until</code>; or if the command is the left hand operand of an <code>&amp;&</code> or <code>||</code> operator.</blockquote><p>I will refer to the term <em>tested command</em> as defined above throughout the post.<section id="The-good-things"><h2>The good things</h2><p>The above description sounds useful. For example, I wouldn’t want my backup script to silently ignore that <code>cp</code> failed and then happily run <code>rm</code> on the original files.<p>And it’s still possible to act upon a failure by using tested commands. For a trivial example, to try until <code>cp</code> in the backup script succeeded, I could write it this way:<pre><code>until cp original backup; do
    sleep 1
done
rm original
</code></pre><p>Setting errexit isn’t the only way to achieve this quit-on-error behavior. One can manually check the exit code of every command in a script and then decide to quit—like so:<pre><code>cp original backup || exit
</code></pre></section><section id="The-bad-things"><h2>The bad things</h2><p>It turns out, however, that errexit isn’t that amazing. What prompted me to write this post is that I’ve recently noticed that ShellCheck provides the <code>--enable all</code> flag, which surely sounds like a <s>yak-shaving contest</s> state-of-the-art thing. Obviously, it reported new errors when I ran it on a script that previously passed with flying colors. In particular, the following snippet was marked with <a href="https://github.com/koalaman/shellcheck/wiki/SC2310">error SC2310</a>.<pre><code>if ! there_is_rebase_in_progress; then
    return
fi
# some other commands follow
</code></pre><p>To quickly quote ShellCheck’s documentation:<blockquote><p>ShellCheck found a function used as a condition in a script where <code>set -e</code> is enabled. This means that the function will run without <code>set -e</code>, and will power through any errors.<p>This applies to <code>if</code>, <code>while</code>, and <code>until</code> statements, commands negated with <code>!</code>, as well as the left-hand side of <code>||</code> and <code>&amp;&</code>. It does not matter how deeply the command is nested in such a structure.</blockquote><p>To rephrase: because this is a tested function, the errors that happen inside it will be ignored; neither the function nor the script will terminate because of an error. This is—broken? I can’t name a single thing that’s good about this. And ShellCheck does not report it by default!<div class="aside"><p>Why is this the case? My first guess would be the following. Let’s remember that—despite errexit being set—one can still do checks like <code>until cp</code> mentioned above. An extremely crude way of implementing that would be to stop errexit from taking effect before the check and enable it again afterward. Voilà. But that’s just a wild guess.</div><p>One thing that complicates the matter is that explicitly setting errexit again in the tested function has no effect: errors will be ignored, <em>even in a subshell</em>.<section id="Other-problems"><h3>Other problems</h3><p>There are other problems with errexit—that our state-of-the-art thing fixed—I won’t focus on in this post. First, commands registered with <code>trap</code> are not fired if an error terminating the execution happens in a function. Bash provides <code>set -E</code> option for this.<p>And if you’re wondering how error handling looks in pipelines, well, they just power through all errors. I don’t know what you expected. Bash makes it possible to change that with <code>-o pipefail</code> option. For POSIX, you’d need to refactor your code to use named pipes—or use a proper language already.</section></section><section id="Ideal-behaviour"><h2>Ideal behaviour</h2><p>Let’s think what would the ideal behavior here. The following three statements hold when errexit is set:<ul><li>an explicit non-zero return from an <em>untested</em> function should terminate the script;<li>an explicit non-zero return from a <em>tested</em> function should <em>not</em> terminate the script;<li>an error inside an <em>untested</em> function should terminate both the function and the script.</ul><p>I think the following two statements should hold as well:<ul><li>an error inside a tested function should terminate the function;<li>an error inside a tested function should terminate the script.</ul><p>Any untested error in execution would then terminate the script, which is robust and easy to reason about. To allow an error to happen one would need to make it tested. To ignore an error and continue the function, one can do this:<pre><code>some_command || :  # colon is same as true, a no-op
</code></pre><p>If one wanted to allow an error to happen inside the function and terminate the function but not the script, one would need to make an explicit return:<pre><code>some_command || return $some_code
</code></pre></section><section id="Workarounds"><h2>Workarounds</h2><p>At this point, you are aware the problem even exists, and you can make an informed decision about whether this is something that bothers you or not. If it does, I’ve come up with some workarounds.<section id="1:-Don't-use-errexit"><h3>1: Don’t use errexit</h3><p>IMHO this is throwing the baby out with the water. Every single command has to be tested individually.</section><section id="2:-Don't-be-fancy"><h3>2: Don’t be fancy</h3><p>Obviously this issue doesn’t affect a script if it doesn’t use tested functions or subshells. I would guesstimate the vast majority of scripts is not affected, simply because they don’t even define any functions. Using functions in a tested context is somewhat uncommon—and plain odd in the case of subshells.<p>So the workaround is to avoid functions and subshells, or at least avoid them in tested contexts.<p>If one needs some kind of status propagation one can use stdout, stderr, or other stream, or a variable.</section><section id="3:-Move-tested-functions-to-scripts"><h3>3: Move tested functions to scripts</h3><p>Probably the simplest workaround: one can define their tested functions in other files and run them as scripts. Then they will run as any other program would, and the disabled state of errexit will not leak to children. One could even place them in a dedicated directory alongside an explanatory README.</section><section id="4:-Source-and-run"><h3>4: Source and run</h3><p>Run the function with something akin to:<pre><code>sh -ec ". ${this-script}; some_function"
</code></pre><p>Similar to the previous one, but still allowing the script to be self-contained—well, mostly. The script must<sup>*</sup> be a library, otherwise sourcing it will trigger side-effects. This in turn means that the script was itself sourced by something else, and one needs to resort to some shenanigans to know the path to the script, as POSIX doesn’t provide a built-in way to obtain it.<div class="aside"><p>* <em>I think</em> there is a way to make the script truly self-contained. See this <a href="https://blog.dnmfarrell.com/post/modulinos-in-bash/">short article on modulinos in bash</a>. However, I’m not sure how a POSIX-compliant modulino would look like.</div></section><section id="5:-Test-everything-in-tested-functions"><h3>5: Test everything in tested functions</h3><blockquote><p>If a shell function is executed and its exit status is explicitly tested, all commands of the function are considered to be tested as well.</blockquote><p>The above phrasing of the issue—found in FreeBSD’s sh manual—gave me an idea that one might just test all the commands inside the affected function explicitly. If the surface area to test is small, it might be a good solution. It needs to me remembered though, that the surface area grows recursively with every function call made in the function.</section><section id="6:-set--e-guards"><h3>6: <code>set -e</code> guards</h3><p>We can perform the following sequence: (1) disable errexit before calling the function; (2) enable errexit inside the function; (3) enable errexit back after the function call. See the example below. For this to work, we need to define the function using a subshell—note the parentheses in lieu of curly braces—so setting errexit doesn’t propagate outwards to the caller.<pre><code>some_function() (
    set -e
    false # terminates and returns 1
    return 2
)

set +e; some_function; exit_code="$?"; set -e

if test "${exit_code}" = 1; then
    echo "This is echoed"
fi
</code></pre><p>The first consideration is that this approach is intrusive: one needs to change braces to parentheses and run <code>set -e</code> at the beginning for every affected function, which might be a little error prone.<p>Second, subshells are slow<sup>†</sup>. That said—unless the code is extremely subshell-heavy, it’s not going to be noticeable.<div class="aside"><p>† See this <a href="https://www.shellcheck.net/wiki/SC2235">ShellCheck entry on subshell performance</a> for more details. Out of curiosity I ran the benchmark presented there on both dash and bash. In both cases the version without subshells was <em>significantly</em> faster—double digit milliseconds versus single digit seconds. However, in both cases dash was at least two times faster than bash.</div><p>Subshells have a nice property of isolating changes made to variables inside them, cutting down on mutable global state. This alone is a good reason to use them to define all the functions. Non-POSIX <code>local</code> keyword provided by some shells achieves the same purpose.</section><section id="7:-Substitution-sandbox-dash-specific"><h3>7: Substitution sandbox (dash-specific)</h3><p>If an author of a script knows they are targeting only dash shell, they can leverage its quirk, which probably is a bug, but I prefer to call it a happy little accident. For whatever reason, the problem disappears if command substitution is used to assign stdout of a function to a variable. If there’s no need to save the output, it can be assigned to <code>_</code> variable, however, no one sane reading this will understand it without an explanatory comment. Let’s see it in action:<pre><code>if _="$(some_function)"; then
    echo "This is echoed on success"
fi
</code></pre><p>If one wanted to do something only in case of failure, they can use <code>!</code> to invert the exit code:<pre><code>if ! _="$(some_function)"; then
    echo "This is echoed on failure"
fi
</code></pre><p>However, this collapses all 255 nonzero exit codes into one, losing information. A simple workaround is to use a no-op command in the success branch—like so:<pre><code>if _="$(some_function)"; then
    :
else
    exit_code="$?"
fi
</code></pre><p>One could also want to save the exit code in both success and failure branches. This can be shortened to arrive at this one-liner. Behold the substitution sandbox:<pre><code>_="$(some_function)" &amp;& ec="$?" || ec="$?"
</code></pre><p>This is actually really neat. One is free to use stdout for whatever they wish, there’s no need to make your hands dirty with global variables, no modifications to the function are required, and it’s not <em>that</em> noisy syntax-wise. Too bad it doesn’t work in any other shell I tried, it would make for a nice idiom. <em>Substitution sandbox</em>, it does have a nice ring to it, doesn’t it?</section></section><section id="Closing-thoughts"><h2>Closing thoughts</h2><p>Man this is fucked up. I like shell. I want to like it. But it’s painful sometimes.<p>If there’s one takeway here, it’s this: use ShellCheck. You will quote everything like a madman. It will not catch <em>everything</em>. But it is good.<p>By the way, hello world! That’s my first post, and hopefully not the last.</section></section></main></div><footer><div id="footer-content"><div><p>This blog is powered by sed. And snails 🐌<p>Gzipped with ❤️—how else—down to 7.0K</div></div></footer>
