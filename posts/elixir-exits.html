<!DOCTYPE html><html lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name="theme-color" content="#66023C"><meta name="color-scheme" content="light dark"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><style type="text/css">:root{--footer-height:9rem;--content-width:40rem;--content-x-padding:1.5rem}h1{font-size:3rem;line-height:1.1}body{line-height:1.5;margin:0}#nav-body{min-height:calc(100svh - var(--footer-height))}main,nav,#footer-content{max-width:var(--content-width);margin:0 auto}main,nav{padding:1rem var(--content-x-padding)}nav a{font-size:smaller;text-decoration:none;font-weight:bold}nav ul,nav li{display:inline;margin-right:1em}footer{font-size:smaller;background:#66023C;color:white}#snail{max-width:50%;margin:0 auto;height:auto;display:block}#footer-content{height:var(--footer-height);padding:0 var(--content-x-padding);display:flex;align-items:center}pre code{overflow:auto}main{hyphens:auto}body{font-family:sans-serif}h1{hyphens:none}.aside,blockquote,pre code{padding:.5em}.aside{border-top:thin solid;border-bottom:thin solid;font-size:smaller}p:first-child{margin-top:0}p:last-child{margin-bottom:0}img{max-width:100%}sup{vertical-align:baseline;position:relative;top:-0.4em}blockquote,li,p{text-align:justify}span.published-date{font-size:smaller}code{font-style:normal;padding:.1em .2em;white-space:pre;font-family:monospace,monospace}pre code{border:thin solid;display:block;font-size:smaller}blockquote{margin:0;border-left:thin solid;font-style:oblique}ol,ul{margin-left:0;padding-left:0}#post-listing li{list-style-type:none}#skip{background:#66023C;color:white;padding:.3em;position:absolute;transform:translateY(-100%)}#skip:focus{transform:translateY(0%)}</style><title>Note on process exits in Elixir</title><script>window.matchMedia('(prefers-color-scheme:dark)').addEventListener('change',event=>document.documentElement.style["color-scheme"]=event.matches?"dark":"light");</script><div id="nav-body"><a href="#main" id="skip">Skip to content</a><nav><ul><li><a href="/index.html">snails.dev</a></ul></nav><main id="#main"><section id="Note-on-process-exits-in-Elixir"><h1>Note on process exits in Elixir</h1><p><span class="published-date">2023-08-14</span><p>I learned Elixir, <em>the syntax</em>, a while ago, now I‚Äôm in the process of learning Elixir, <em>the semantics</em>.<p>I was initially confused by the functionality around process exits. This note is my attempt of wrapping my head around the semantics and implications of process deaths, exit signals, exit trapping, and process monitoring.<p>Hopefully there are no glaring errors here, but I‚Äôm still learning, so all bets are off.<section id="Exit-reason-and-exit-signals"><h2>Exit reason and exit signals</h2><p>First off, processes always exit with a <em>reason</em>, a value that influences how the exit plays out.<p>A process can exit because of (I think?) three causes. The cause of death doesn‚Äôt directly influence the exit scenario. It does influence it indirectly, through the exit reason. The causes are the following:<ul><li>returning the result of the final expression, reason <code>:normal</code>;<li>raising an error, reason being the error;<li>receiving an exit signal from another process, reason contained in the signal.</ul><p>Sending an exit signal can be performed by the following invocation.<pre><code class="language-elixir">Process.exit(pid, reason)
</code></pre><p>What happens when a process receives an exit signal can be represented by the following bullet list. The list is evaluated until the first condition is true.<ul><li>If the reason in an exit signal is <code>:kill</code>, the process unconditionally dies.<li>Otherwise, if trapping exits, the signal is converted to a message, sent to the process, and the process doesn‚Äôt die.<li>Otherwise, if reason is not <code>:normal</code>, the process dies.<li>Otherwise, if the source and target of the signal are the same, the process dies.<li>Otherwise, the process doesn‚Äôt die.</ul></section><section id="Links"><h2>Links</h2><p>When a process exits, regardless of the cause, the processes linked to that process also receive an exit signal. If the reason for exit was <code>:kill</code>, the reason sent in the signal to the linked processes is <code>:killed</code>. This is to avoid recursively and unconditionally killing everything linked to the process. If the reason was different from <code>:kill</code>, the original reason is used.</section><section id="Trapping-exits"><h2>Trapping exits</h2><p>Trapping exits means that an exit signal‚Äîwith reason other than <code>:kill</code>‚Äîis delivered to a process inbox as a normal message. The shape of the message is as follows; <code>from</code> being a pid:<pre><code class="language-elixir">{:EXIT, from, reason}
</code></pre><p>To enable trapping exits for given process, the process needs to call<pre><code class="language-elixir">Process.flag(:trap_exit, true)
</code></pre><p>By having trapping exits enabled for some process <code>pid</code>, these things change:<ul><li>signals with <code>:normal</code> reason still don‚Äôt kill <code>pid</code>, but are not entirely ignored either;<li>signals with reason other than <code>:normal</code> or <code>:kill</code> no longer kill <code>pid</code> and can be reacted to;<li>death of a process linked to <code>pid</code> no longer spells doom for <code>pid</code>.</ul></section><section id="exit-snippet"><h2><code>exit</code> snippet</h2><p>The above observations can be summarized by the following snippet. This is not the actual definition of <code>exit</code>, it‚Äôs just a simple rendering of the rules stated above. In the snippet, <code>die</code> is a hypothetical function cleaning up after the process.<pre><code class="language-elixir">def exit(target, reason) do
  target_info = Process.info(target)
  trapping? = Keyword.get(target_info, :trap_exit)
  linked = Keyword.get(target_info, :links)

  cond do
    reason == :kill -&gt;
      for p &lt;- linked, do: exit(p, :killed)
      die(target)
    trapping? -&gt;
      send(target, {:EXIT, self(), reason})
    reason != :normal -&gt;
      for p &lt;- linked, do: exit(p, reason)
      die(target)
    self() == target -&gt;
      for p &lt;- linked, do: exit(p, :normal)
      die(target)
    true -&gt;
      nil
  end
</code></pre><p>Hopefully, I‚Äôll learn enough Erlang to be dangerous soon enough, and see how that‚Äôs really implemented.</section><section id="Monitoring"><h2>Monitoring</h2><p>One process‚Äîsay, <code>foo</code>‚Äîcan also monitor another process‚Äî<code>bar</code>. This is done by running this line in <code>foo</code>:<pre><code>ref = Process.monitor(bar)
</code></pre><p>When <code>bar</code> exits, <code>foo</code> receives the message of the following shape:<pre><code class="language-elixir">{:DOWN, ^ref, :process, ^bar, reason}
</code></pre><p>Monitoring is unidirectional: when <code>foo</code> exits, <code>bar</code> is not notified.</section><section id="QA"><h2>Q&amp;A</h2><p>Now, a little Q&amp;A with myself to summarize all this information.<p><strong>Q: When to link two processes without trapping exits?</strong><p><strong>A</strong>: When you want an exit with non-<code>:normal</code> reason in one process to make the other process exit as well.<p><strong>Q: When to make process <code>foo</code> monitor another process <code>bar</code>?</strong><p><strong>A</strong>: Monitoring is unidirectional, so when you want <code>foo</code> to be notified that <code>bar</code> exited, but not the other way around. Additionally, the monitoring process handles exits in the default way.<p><strong>Q: Do supervisors use linking or monitoring then?</strong><p><strong>A</strong>: Linking. A dying supervisor also brings down all of its children.<p><strong>Q: So when is monitoring useful?</strong><p><strong>A</strong>: I think when the monitored process can carry on even when the monitoring process dies.<p><strong>Q: When to link processes with trapping exits?</strong><p><strong>A</strong>: When you want two processes to react in a custom way to each other‚Äôs exits.<p><strong>Q: Do I ever want to trap exits without linking to anything?</strong><p><strong>A</strong>: I don‚Äôt know if it‚Äôs actually done in the wild, but this allows other processes to call <code>Process.exit</code> on <code>foo</code>, and have <code>foo</code> implement some custom logic for handling that.<p><strong>Q: Why not send normal messages then?</strong><p><strong>A</strong>: You could do that, but <code>Process.exit</code> is there, and maybe it fits that particular use case. I guess.<p><strong>Q: Do I ever want two processes to monitor each other?</strong><p><strong>A</strong>: Probably not. This is very similar to linking two processes with trapping exits; there is a subtle difference though. The processes monitoring each other handle <em>their own</em> exit signals in the default way.</section></section></main></div><footer><div id="footer-content"><div><p>This blog is powered by sed. And snails üêå<p>Gzipped with ‚ù§Ô∏è‚Äîhow else‚Äîdown to 4.0K</div></div></footer>
